/**
 * This file contains the completion function for the general agent.
 *
 * Agent Action Function needs to follow the following criteria:
 * 1. It should use its respective system prompt
 * 2. It should deduct tokens from the users account (IMPORTANT)
 * 3. It should return the response like { success: true, message: "response", totalTokens: 100 } if everything is correct
 * 4. It should return the response line {success: false, message "error message"} if something goes wrong
 */

"use server";

import { z } from "zod";
import OpenAITextCompletion from "../openai-completion";
import { ConversationWithOutSystemPromptSchema } from "@/server/validation/openai/openai-messages";
import { PromptFactory } from "@/server/prompts/prompt-factory";
import TurnRepo from "@/server/database/repositories/turn";
import VocabAgentSuggestionRepo from "@/server/database/repositories/vocab-agent-suggestion";
import validateOrCreateConversation from "../general/validate-conversation-id";
import VocabAgentCompletion from "../vocab/completion";
import UserRepo from "@/server/database/repositories/user";
import VocabularyBucketRepo from "@/server/database/repositories/vocabulary-bucket";
import VocabularyRepo from "@/server/database/repositories/vocabulary";
import RoleplayRepo from "@/server/database/repositories/roleplay";
import {
  checkEntitlement,
  EntitlementSlugs,
} from "../../entitlement/check-entitlement";
import recordOneMessageUseInDBForUser from "../../stripe/record-usage";

export default async function RoleplayAgentCompletion(
  userId: string,
  roleplayId: string,
  messages: z.infer<typeof ConversationWithOutSystemPromptSchema>,
  conversationId?: string,
  requestNewConversation?: boolean,
  useVocabAgent?: boolean
) {
  try {
    // TODO: check if user have tokens to generate the response
    // Validate the conversation and get the current conversationId or create a new one if needed
    let conversation = await validateOrCreateConversation(
      userId,
      messages,
      conversationId,
      requestNewConversation,
      roleplayId
    );

    const hasLimitedChat = await checkEntitlement(
      userId,
      EntitlementSlugs.VOCABLET_AI_CHAT_LIMITED
    );

    const hasUnlimitedChat = await checkEntitlement(
      userId,
      EntitlementSlugs.VOCABLET_AI_CHAT_UNLIMITED
    );

    if (!hasLimitedChat && !hasUnlimitedChat) {
      return {
        success: false,
        message:
          "You do not have access to use this feature. Upgrade your plan to use this feature.",
      };
    } else if (hasLimitedChat) {
      // cout the number of user messages
      const userMessages = messages.filter(
        (message) => message.role === "user"
      );
      if (userMessages.length > 30) {
        return {
          success: false,
          message:
            "You have reached the limit of messages for this conversation. Upgrade your plan or create a new conversation.",
        };
      }
    }

    // if the messages list is greater than 15 then only extract the last 15 messages
    if (messages.length > 10) {
      messages = messages.slice(messages.length - 10, messages.length);
    }

    const roleplayResponse = await RoleplayRepo.findRoleplayById(roleplayId);
    // console.log('roleplay:::', roleplayResponse);
    let conversationIdCurrent = conversation.id;
    let system_prompt;
    if (roleplayResponse) {
      system_prompt = PromptFactory.getDynamicRolePlaySystemPrompt(
        roleplayResponse?.assistantRole,
        roleplayResponse?.userRole,
        roleplayResponse?.conversationTone,
        roleplayResponse?.conversationContext
      );
    } else {
      system_prompt = PromptFactory.getDefaultSystemPrompt();
    }

    // STRIPE_SUBSCRIPTION record the message usage
    await recordOneMessageUseInDBForUser(userId);

    const [reply, totalTokens] = await OpenAITextCompletion(
      messages,
      system_prompt
    );
    if (!reply || !totalTokens) {
      throw new Error(
        "Failed to generate a response or calculate total tokens."
      );
    }

    // Record the turn in the database
    const turn = await TurnRepo.CreateTurnInDB(
      userId,
      conversationIdCurrent,
      messages[messages.length - 1].content,
      reply + "",
      totalTokens as number
    );
    if (!turn) {
      throw new Error("Failed to record the turn in the database.");
    }

    // TODO: use api call maybe?
    // Create a vocabulary bucket in the database if it does not exist in the user tables autoGeneratedBucketId.
    let user = await UserRepo.findUserById(userId);
    if (user?.autoGeneratedBucketId === null) {
      // create a new bucket
      const newBucket = await VocabularyBucketRepo.createVocabularyBucket(
        userId,
        "My Default Bucket"
      );
      // update the user table with the new bucket id
      user = await UserRepo.updateAutoGeneratedBucketId(userId, newBucket.id);
    }

    if (useVocabAgent) {
      // Call the completion function for the VocabAgent
      const vocabData = await VocabAgentCompletion(userId, messages);

      // Check if the completion function was successful
      if (!vocabData.success)
        throw new Error(
          vocabData.message as string | "Vocabulary search error."
        );
      const vocabDataWords = vocabData.words as string;
      const wordString = vocabDataWords.replace(/'/g, '"');
      const words = JSON.parse(wordString);

      const enhanced_words = vocabData.enhanced_words;

      // console.log('words:: ', words);
      // add to the database VocabAgentSuggestion
      const vocabAgentSuggestion =
        await VocabAgentSuggestionRepo.createVocabAgentSuggestion(
          turn.id,
          vocabData.totalTokens as number,
          vocabData.enhanced_text as string,
          enhanced_words as string[]
        );

      if (!vocabAgentSuggestion) {
        throw new Error(
          "Failed to record the VocabAgentSuggestion in the database."
        );
      }

      // create the vocabularies in the database with words
      for (const word of words) {
        await VocabularyRepo.createVocabulary(
          user?.autoGeneratedBucketId as string,
          word
        );
      }

      return {
        success: true,
        message: reply,
        totalTokens: totalTokens,
        conversationId: conversationIdCurrent,
        title: conversation.title,
        createdAt: conversation.createdAt,
        vocab_agent_response: vocabData,
      };
    }

    return {
      success: true,
      message: reply,
      totalTokens: totalTokens,
      conversationId: conversationIdCurrent,
      title: conversation.title,
      createdAt: conversation.createdAt,
    };
  } catch (error) {
    return {
      success: false,
      message: (error as Error).message,
    };
  }
}
