/**
 * This file contains the completion function for the general agent.
 *
 * Agent Action Function needs to follow the following criteria:
 * 1. It should use its respective system prompt
 * 2. It should deduct tokens from the users account (IMPORTANT)
 * 3. It should return the response like { success: true, message: "response", totalTokens: 100 } if everything is correct
 * 4. It should return the response line {success: false, message "error message"} if something goes wrong
 */

"use server";

import { z } from "zod";
import OpenAITextCompletion from "../openai-completion";
import { ConversationWithOutSystemPromptSchema } from "@/server/validation/openai/openai-messages";
import { PromptFactory } from "@/server/prompts/prompt-factory";
import DeductTokenFromUserAccountForMessage from "../../usage/token-deduction";
import TurnRepo from "@/server/database/repositories/turn";
import VocabAgentSuggestionRepo from "@/server/database/repositories/vocab-agent-suggestion";
// import validateOrCreateConversation from "./validate-conversation-id";
import VocabAgentCompletion from "../vocab/completion";
import UserRepo from "@/server/database/repositories/user";
import VocabularyBucketRepo from "@/server/database/repositories/vocabulary-bucket";
import VocabularyRepo from "@/server/database/repositories/vocabulary";

export default async function WordSuggesterCompletion(
    userId: string,
    messages: z.infer<typeof ConversationWithOutSystemPromptSchema>,
) {
    try {
        // TODO: check if user have tokens to generate the response

        // Get the last message from the messages array.
        const lastMessage = messages[messages.length - 1];


   
        const promptMessageWordSuggest = `Provide minimum 12 and maximum 20 advanced & unique vocabularies based the the scenario & domain delimited by """. \n """ ${lastMessage.content} """`;
        const wordSuggestInput = {
            role: lastMessage.role,
            content: promptMessageWordSuggest,
        };

        // If the last message is not by the user, return an error.
        if (wordSuggestInput.role !== "user") {
            throw new Error("The last message should be from the user.");
        }
        // Convert the lastMessage to ConversationWithOutSystemPromptSchema
        const validatedWordSuggestMessage =
            ConversationWithOutSystemPromptSchema.parse([wordSuggestInput]);


        let system_prompt = PromptFactory.getWordSuggestSystemPrompt();
        const [reply, totalTokens] = await OpenAITextCompletion(
            validatedWordSuggestMessage,
            system_prompt,
        );
        if (!reply || !totalTokens) {
            throw new Error(
                "Failed to generate a response or calculate total tokens."
            );
        }

        // TODO: use api call maybe?
        // Create a vocabulary bucket in the database if it does not exist in the user tables autoGeneratedBucketId.
        let user = await UserRepo.findUserById(userId);
        if (user?.autoGeneratedBucketId === null) {

            // create a new bucket
            const newBucket = await VocabularyBucketRepo.createVocabularyBucket(userId, "My Default Bucket");
            // update the user table with the new bucket id
            user = await UserRepo.updateAutoGeneratedBucketId(userId, newBucket.id);
        }

        return {
            success: true,
            words: reply,
        };
    } catch (error) {
        return {
            success: false,
            message: (error as Error).message,
        };
    }
}
