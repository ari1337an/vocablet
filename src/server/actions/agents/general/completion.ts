"use server";

import { z } from "zod";
import OpenAITextCompletion from "../openai-completion";
import { ConversationWithOutSystemPromptSchema } from "@/server/validation/openai/openai-messages";
import { PromptFactory } from "@/server/prompts/prompt-factory";
import DeductTokenFromUserAccountForMessage from "../../usage/token-deduction";
import TurnRepo from "@/server/database/repositories/turn";
import VocabAgentSuggestionRepo from "@/server/database/repositories/vocab-agent-suggestion";
import validateOrCreateConversation from "./validate-conversation-id";
import VocabAgentCompletion from "../vocab/completion";
import UserRepo from "@/server/database/repositories/user";
import VocabularyBucketRepo from "@/server/database/repositories/vocabulary-bucket";
import VocabularyRepo from "@/server/database/repositories/vocabulary";

function isValidJson(response: string) {
  try {
    JSON.parse(response);
    return true;
  } catch (e) {
    return false;
  }
}

export default async function GeneralAgentCompletion(
  userId: string,
  messages: z.infer<typeof ConversationWithOutSystemPromptSchema>,
  conversationId?: string,
  requestNewConversation?: boolean,
  useVocabAgent?: boolean,
  minimum_words?: number,
) {
  try {
    // TODO: check if user have tokens to generate the response
    // Validate the conversation and get the current conversationId or create a new one if needed
    let conversation = await validateOrCreateConversation(
      userId,
      messages,
      conversationId,
      requestNewConversation
    );

    // Validate conversation response
    if (!isValidJson(JSON.stringify(conversation))) {
      throw new Error("Invalid JSON response from validateOrCreateConversation.");
    }

    let conversationIdCurrent = conversation.id;
    let system_prompt = PromptFactory.getDefaultSystemPrompt();
    const [reply, totalTokens] = await OpenAITextCompletion(
      messages,
      system_prompt
    );

    // Validate OpenAITextCompletion response
    if (!reply || !totalTokens || !isValidJson(JSON.stringify([reply, totalTokens]))) {
      throw new Error(
        "Failed to generate a response or calculate total tokens."
      );
    }

    // Record the turn in the database
    const turn = await TurnRepo.CreateTurnInDB(
      userId,
      conversationIdCurrent,
      messages[messages.length - 1].content,
      reply + "",
      totalTokens as number
    );

    // Validate turn response
    if (!turn || !isValidJson(JSON.stringify(turn))) {
      throw new Error("Failed to record the turn in the database.");
    }

    // Deduct tokens from the user's account
    await DeductTokenFromUserAccountForMessage(
      userId,
      turn.id,
      parseInt(totalTokens + "", 10)
    );

    // Validate token deduction response (assuming it returns a value)
    if (!isValidJson(JSON.stringify({ userId, turnId: turn.id, totalTokens }))) {
      throw new Error("Invalid JSON response from token deduction.");
    }

    // Create a vocabulary bucket in the database if it does not exist in the user tables autoGeneratedBucketId.
    let user = await UserRepo.findUserById(userId);

    // Validate user response
    if (!user || !isValidJson(JSON.stringify(user))) {
      throw new Error("Invalid JSON response from finding user.");
    }

    if (user?.autoGeneratedBucketId === null) {
      // create a new bucket
      const newBucket = await VocabularyBucketRepo.createVocabularyBucket(userId, "My Default Bucket");

      // Validate new bucket response
      if (!newBucket || !isValidJson(JSON.stringify(newBucket))) {
        throw new Error("Invalid JSON response from creating vocabulary bucket.");
      }

      // update the user table with the new bucket id
      user = await UserRepo.updateAutoGeneratedBucketId(userId, newBucket.id);

      // Validate user update response
      if (!user || !isValidJson(JSON.stringify(user))) {
        throw new Error("Invalid JSON response from updating user bucket id.");
      }
    }

    if (useVocabAgent) {
      // Call the completion function for the VocabAgent
      let vocabData;
      if(minimum_words){

        vocabData = await VocabAgentCompletion(userId, messages, minimum_words);
      }else{
        vocabData = await VocabAgentCompletion(userId, messages);
      }

      // Check if the completion function was successful
      if (!vocabData.success) throw new Error(vocabData.message || "Vocabulary search error.");

      // Validate vocab agent response
      if (!isValidJson(JSON.stringify(vocabData))) {
        throw new Error("Invalid JSON response from VocabAgentCompletion.");
      }

      const enhanced_words = vocabData.enhanced_words;
      const words = vocabData.words;

      // add to the database VocabAgentSuggestion
      const vocabAgentSuggestion = await VocabAgentSuggestionRepo.createVocabAgentSuggestion(
        turn.id,
        vocabData.totalTokens as number,
        vocabData.enhanced_text as string,
        enhanced_words as string[],
      );

      // Validate vocab agent suggestion response
      if (!vocabAgentSuggestion || !isValidJson(JSON.stringify(vocabAgentSuggestion))) {
        throw new Error("Failed to record the VocabAgentSuggestion in the database.");
      }

      // create the vocabularies in the database with words
      for (const word of enhanced_words) {
        const vocab = await VocabularyRepo.createVocabulary(user?.autoGeneratedBucketId as string, word);

        // Validate vocabulary creation response
        if (!vocab || !isValidJson(JSON.stringify(vocab))) {
          throw new Error(`Invalid JSON response from creating vocabulary: ${word}`);
        }
      }

      const json_words = JSON.parse(words as string);
      
      for(const word of json_words){
        const vocab = await VocabularyRepo.createVocabulary(user?.autoGeneratedBucketId as string, word);
        // console.log('vocab updated', vocab);
        // Validate vocabulary creation response
        if (!vocab || !isValidJson(JSON.stringify(vocab))) {
          throw new Error(`Invalid JSON response from creating vocabulary: ${word}`);
        }
      }
      // for (const word of words) {
      //   const vocab = await VocabularyRepo.createVocabulary(user?.autoGeneratedBucketId as string, word);

      //   // Validate vocabulary creation response
      //   if (!vocab || !isValidJson(JSON.stringify(vocab))) {
      //     throw new Error(`Invalid JSON response from creating vocabulary: ${word}`);
      //   }
      // }

      return {
        success: true,
        message: reply,
        totalTokens: totalTokens,
        conversationId: conversationIdCurrent,
        title: conversation.title,
        createdAt: conversation.createdAt,
        vocab_agent_response: vocabData,
      };
    }

    return {
      success: true,
      message: reply,
      totalTokens: totalTokens,
      conversationId: conversationIdCurrent,
      title: conversation.title,
      createdAt: conversation.createdAt,
    };
  } catch (error) {
    return {
      success: false,
      message: (error as Error).message,
    };
  }
}
